{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "a451390c-e83b-47ca-a3a9-efad8e38ad72",
   "metadata": {},
   "outputs": [],
   "source": [
    "import json\n",
    "import pandas as pd\n",
    "import matplotlib.pyplot as plt\n",
    "import tkinter as tk\n",
    "from tkinter import ttk\n",
    "from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg\n",
    "\n",
    "\n",
    "class Studiengang:\n",
    "    def __init__(self, name: str):\n",
    "        \"\"\"\n",
    "        Konstruktor der Klasse Studiengang.\n",
    "        Wird aufgerufen, wenn ein neues Studiengang-Objekt erstellt wird.\n",
    "\n",
    "        :param name: Der Name des Studiengangs (z.B. 'Informatik')\n",
    "        \"\"\"\n",
    "        self.name = name  # Speichert den Namen des Studiengangs\n",
    "        self.semester = []  # Liste, in der alle Semester-Objekte gespeichert werden\n",
    "        self.gesamt_ects = 0  # Die Gesamtanzahl der ECTS-Punkte (wird berechnet)\n",
    "        self.abschlussnote = None  # Die Abschlussnote (wird berechnet)\n",
    "\n",
    "    def berechne_gesamt_ects(self):\n",
    "        \"\"\"\n",
    "        Berechnet die Summe aller ECTS-Punkte aus allen Semestern.\n",
    "        Geht davon aus, dass jedes Semester-Objekt eine Methode ects() hat,\n",
    "        die die ECTS-Punkte dieses Semesters zurückgibt.\n",
    "\n",
    "        :return: Die Gesamtanzahl der ECTS-Punkte im Studiengang\n",
    "        \"\"\"\n",
    "        # Für jedes Semester in der Liste self.semester wird die Methode ects() aufgerufen.\n",
    "        # Die Ergebnisse werden aufsummiert.\n",
    "        self.gesamt_ects = sum(sem.ects() for sem in self.semester)\n",
    "        return self.gesamt_ects\n",
    "\n",
    "    def berechne_abschlussnote(self):\n",
    "        \"\"\"\n",
    "        Berechnet die Abschlussnote des Studiengangs.\n",
    "        Hier als Beispiel: Durchschnitt aller Noten aus allen Semestern.\n",
    "        Geht davon aus, dass jedes Semester-Objekt eine Methode noten() hat,\n",
    "        die eine Liste der Noten dieses Semesters zurückgibt.\n",
    "\n",
    "        :return: Die berechnete Abschlussnote (oder None, falls keine Noten vorhanden sind)\n",
    "        \"\"\"\n",
    "        noten = []  # Leere Liste für alle Noten\n",
    "        for sem in self.semester:\n",
    "            noten.extend(sem.noten())  # Alle Noten des Semesters zur Liste hinzufügen\n",
    "        if noten:  # Wenn es Noten gibt\n",
    "            self.abschlussnote = sum(noten) / len(noten)  # Durchschnitt berechnen\n",
    "        else:\n",
    "            self.abschlussnote = None  # Keine Noten vorhanden\n",
    "        return self.abschlussnote\n",
    "\n",
    "    def alle_module(self):\n",
    "        \"\"\"\n",
    "        Gibt eine Liste aller Module aus allen Semestern zurück.\n",
    "        Geht davon aus, dass jedes Semester-Objekt ein Attribut module hat,\n",
    "        das eine Liste der Module dieses Semesters enthält.\n",
    "\n",
    "        :return: Eine Liste aller Module im Studiengang\n",
    "        \"\"\"\n",
    "        module = []  # Leere Liste für alle Module\n",
    "        for sem in self.semester:\n",
    "            module.extend(sem.module)  # Alle Module des Semesters zur Liste hinzufügen\n",
    "        return module\n",
    "\n",
    "class Semester:\n",
    "    def __init__(self, name: str):\n",
    "        \"\"\"\n",
    "        Konstruktor für ein Semester.\n",
    "        :param name: Name des Semesters (z.B. '1. Semester')\n",
    "        \"\"\"\n",
    "        self.name = name  # Name des Semesters\n",
    "        self.module = []  # Liste von Modulen (z.B. Module-Objekte)\n",
    "\n",
    "    def ects(self) -> int:\n",
    "        \"\"\"\n",
    "        Berechnet die Summe der ECTS-Punkte aller Module in diesem Semester.\n",
    "        :return: Gesamt-ECTS dieses Semesters\n",
    "        \"\"\"\n",
    "        return sum(modul.ects for modul in self.module)\n",
    "\n",
    "    def noten(self) -> list:\n",
    "        \"\"\"\n",
    "        Gibt eine Liste aller Noten der Module in diesem Semester zurück.\n",
    "        :return: Liste der Noten (z.B. [1.7, 2.3, 2.0])\n",
    "        \"\"\"\n",
    "        return [modul.note for modul in self.module if modul.note is not None]\n",
    "\n",
    "class Module:\n",
    "    def __init__(self, titel: str, ects: int, pflicht: bool):\n",
    "        \"\"\"\n",
    "        Konstruktor für ein Modul.\n",
    "\n",
    "        :param titel: Name des Moduls\n",
    "        :param ects: ECTS-Punkte des Moduls\n",
    "        :param pflicht: True, wenn Pflichtmodul, sonst False\n",
    "        \"\"\"\n",
    "        self.titel = titel\n",
    "        self.ects = ects\n",
    "        self.pflicht = pflicht\n",
    "        self.pruefungsleistungen = []  # Liste von Pruefungsleistung-Objekten\n",
    "        self.note = None               # Die berechnete Note (z.B. 2.0)\n",
    "        self.bewertung = None          # Textliche Bewertung (z.B. \"gut\")\n",
    "\n",
    "    def pruefungsleistung_hinzufuegen(self, pruefungsleistung: 'Pruefungsleistung'):\n",
    "        \"\"\"\n",
    "        Fügt eine Prüfungsleistung zum Modul hinzu.\n",
    "\n",
    "        :param pruefungsleistung: Ein Pruefungsleistung-Objekt\n",
    "        \"\"\"\n",
    "        self.pruefungsleistungen.append(pruefungsleistung)\n",
    "        self.berechne_note_und_bewertung()\n",
    "\n",
    "    def berechne_note_und_bewertung(self):\n",
    "        \"\"\"\n",
    "        Berechnet die Note und Bewertung des Moduls anhand der Prüfungsleistungen\n",
    "        und dem Bewertungsschema der Uni.\n",
    "        \"\"\"\n",
    "        # Gesamte erreichbare und erreichte Punkte berechnen\n",
    "        gesamt_max = sum(p.max_punkte for p in self.pruefungsleistungen)\n",
    "        gesamt_erreicht = sum(p.erreichte_punkte for p in self.pruefungsleistungen if p.erreichte_punkte is not None)\n",
    "\n",
    "        if gesamt_max == 0 or len(self.pruefungsleistungen) == 0:\n",
    "            self.note = None\n",
    "            self.bewertung = None\n",
    "            return\n",
    "\n",
    "        prozent = (gesamt_erreicht / gesamt_max) * 100\n",
    "\n",
    "        # Bewertungsschema (wie zuvor)\n",
    "        if prozent >= 96:\n",
    "            self.note, self.bewertung = 1.0, \"sehr gut\"\n",
    "        elif prozent >= 91:\n",
    "            self.note, self.bewertung = 1.3, \"sehr gut\"\n",
    "        elif prozent >= 86:\n",
    "            self.note, self.bewertung = 1.7, \"gut\"\n",
    "        elif prozent >= 81:\n",
    "            self.note, self.bewertung = 2.0, \"gut\"\n",
    "        elif prozent >= 76:\n",
    "            self.note, self.bewertung = 2.3, \"gut\"\n",
    "        elif prozent >= 71:\n",
    "            self.note, self.bewertung = 2.7, \"befriedigend\"\n",
    "        elif prozent >= 66:\n",
    "            self.note, self.bewertung = 3.0, \"befriedigend\"\n",
    "        elif prozent >= 61:\n",
    "            self.note, self.bewertung = 3.3, \"befriedigend\"\n",
    "        elif prozent >= 56:\n",
    "            self.note, self.bewertung = 3.7, \"ausreichend\"\n",
    "        elif prozent >= 50:\n",
    "            self.note, self.bewertung = 4.0, \"ausreichend\"\n",
    "        else:\n",
    "            self.note, self.bewertung = 5.0, \"nicht ausreichend\"\n",
    "\n",
    "    def ist_bestanden(self) -> bool:\n",
    "        \"\"\"\n",
    "        Prüft, ob das Modul bestanden ist (Note <= 4.0).\n",
    "        :return: True, wenn bestanden, sonst False\n",
    "        \"\"\"\n",
    "        return self.note is not None and self.note <= 4.0\n",
    "\n",
    "    def erreichte_ects(self) -> int:\n",
    "        \"\"\"\n",
    "        Gibt die ECTS-Punkte zurück, wenn das Modul bestanden ist, sonst 0.\n",
    "        :return: ECTS-Punkte (int), wenn bestanden, sonst 0\n",
    "        \"\"\"\n",
    "        return self.ects if self.ist_bestanden() else 0\n",
    "\n",
    "    def __str__(self):\n",
    "        \"\"\"\n",
    "        Gibt eine lesbare Textdarstellung des Moduls zurück.\n",
    "        :return: String mit Modulinfos\n",
    "        \"\"\"\n",
    "        status = \"bestanden\" if self.ist_bestanden() else \"nicht bestanden\"\n",
    "        note_str = f\"{self.note:.1f}\" if self.note is not None else \"keine Note\"\n",
    "        bewertung_str = self.bewertung if self.bewertung is not None else \"keine Bewertung\"\n",
    "        pflicht_str = \"Pflichtmodul\" if self.pflicht else \"Wahlmodul\"\n",
    "        return (f\"{self.titel} ({pflicht_str}, {self.ects} ECTS, \"\n",
    "                f\"Note: {note_str}, Bewertung: {bewertung_str}, {status})\")\n",
    "\n",
    "class User:\n",
    "    def __init__(self, name: str, matrikelnummer: str, studiengang: 'Studiengang',\n",
    "                 ziel_abschluss_jahre: int = 3, ziel_note: float = 2.0):\n",
    "        \"\"\"\n",
    "        Konstruktor für einen User (Studierenden).\n",
    "\n",
    "        :param name: Name des Users (z.B. 'Max Mustermann')\n",
    "        :param matrikelnummer: Matrikelnummer des Users (z.B. '1234567')\n",
    "        :param studiengang: Ein Studiengang-Objekt, das den Studiengang des Users repräsentiert\n",
    "        :param ziel_abschluss_jahre: In wie vielen Jahren der Abschluss geschafft werden soll (Standard: 3)\n",
    "        :param ziel_note: Gewünschter maximaler Notendurchschnitt (Standard: 2.0)\n",
    "        \"\"\"\n",
    "        self.name = name\n",
    "        self.matrikelnummer = matrikelnummer\n",
    "        self.studiengang = studiengang\n",
    "        self.ziel_abschluss_jahre = ziel_abschluss_jahre\n",
    "        self.ziel_note = ziel_note\n",
    "\n",
    "    def user_info(self) -> str:\n",
    "        \"\"\"\n",
    "        Gibt eine kurze Übersicht über den User und seinen Studiengang zurück.\n",
    "\n",
    "        :return: String mit User-Informationen\n",
    "        \"\"\"\n",
    "        return (f\"Name: {self.name}\\n\"\n",
    "                f\"Matrikelnummer: {self.matrikelnummer}\\n\"\n",
    "                f\"Studiengang: {self.studiengang.name}\")\n",
    "\n",
    "    def aktueller_ects(self) -> int:\n",
    "        \"\"\"\n",
    "        Gibt die aktuell im Studiengang erreichten ECTS-Punkte zurück.\n",
    "\n",
    "        :return: Anzahl der ECTS-Punkte\n",
    "        \"\"\"\n",
    "        return self.studiengang.berechne_gesamt_ects()\n",
    "\n",
    "    def aktuelle_abschlussnote(self):\n",
    "        \"\"\"\n",
    "        Gibt die aktuelle Abschlussnote des Users zurück (sofern berechenbar).\n",
    "\n",
    "        :return: Abschlussnote (float) oder None\n",
    "        \"\"\"\n",
    "        return self.studiengang.berechne_abschlussnote()\n",
    "\n",
    "    def ziel_abschluss_erreicht(self) -> bool:\n",
    "        \"\"\"\n",
    "        Prüft, ob der Abschluss innerhalb der Zieljahre erreicht wurde.\n",
    "        Annahme: 2 Semester pro Jahr.\n",
    "        Optional: Passe die ECTS-Grenze an deinen Studiengang an (z.B. 180 für Bachelor).\n",
    "        \"\"\"\n",
    "        anzahl_semester = len(self.studiengang.semester)\n",
    "        max_semester = self.ziel_abschluss_jahre * 2\n",
    "        return (anzahl_semester <= max_semester and\n",
    "                self.studiengang.berechne_gesamt_ects() >= 180)  # Beispiel: 180 ECTS für Bachelor\n",
    "\n",
    "    def ziel_note_erreicht(self) -> bool:\n",
    "        \"\"\"\n",
    "        Prüft, ob der Notendurchschnitt das Ziel erfüllt.\n",
    "\n",
    "        :return: True, wenn der Notendurchschnitt ≤ Zielnote, sonst False\n",
    "        \"\"\"\n",
    "        note = self.studiengang.berechne_abschlussnote()\n",
    "        return note is not None and note <= self.ziel_note\n",
    "\n",
    "    def ziel_status(self) -> str:\n",
    "        \"\"\"\n",
    "        Gibt eine Übersicht, ob die Ziele erreicht wurden.\n",
    "\n",
    "        :return: String mit Zielstatus\n",
    "        \"\"\"\n",
    "        status_abschluss = \"erreicht\" if self.ziel_abschluss_erreicht() else \"nicht erreicht\"\n",
    "        status_note = \"erreicht\" if self.ziel_note_erreicht() else \"nicht erreicht\"\n",
    "        return (f\"Ziel Abschluss in {self.ziel_abschluss_jahre} Jahren: {status_abschluss}\\n\"\n",
    "                f\"Ziel Notendurchschnitt ≤ {self.ziel_note}: {status_note}\")\n",
    "\n",
    "    def __str__(self):\n",
    "        \"\"\"\n",
    "        Gibt eine kompakte Textdarstellung des Users zurück.\n",
    "\n",
    "        :return: String mit Userdaten\n",
    "        \"\"\"\n",
    "        return f\"{self.name} ({self.matrikelnummer}), Studiengang: {self.studiengang.name}\"\n",
    "        \n",
    "class Pruefungsleistung:\n",
    "    def __init__(self, titel: str, max_punkte: float, erreichte_punkte: float = None, datum: str = None):\n",
    "        \"\"\"\n",
    "        Konstruktor für eine Prüfungsleistung.\n",
    "\n",
    "        :param titel: Name der Prüfungsleistung (z.B. 'Klausur', 'Hausarbeit')\n",
    "        :param max_punkte: Maximale erreichbare Punktzahl\n",
    "        :param erreichte_punkte: Erreichte Punktzahl (optional, kann None sein)\n",
    "        :param datum: Datum der Prüfungsleistung (optional, z.B. '2024-07-15')\n",
    "        \"\"\"\n",
    "        self.titel = titel  # Name der Prüfungsleistung\n",
    "        self.max_punkte = max_punkte  # Maximale Punktzahl\n",
    "        self.erreichte_punkte = erreichte_punkte  # Erreichte Punktzahl (kann None sein)\n",
    "        self.datum = datum  # Datum der Prüfungsleistung (optional)\n",
    "\n",
    "    def prozent(self) -> float:\n",
    "        \"\"\"\n",
    "        Berechnet den Prozentsatz der erreichten Punkte.\n",
    "\n",
    "        :return: Prozentwert (0-100) oder None, falls keine Punkte eingetragen sind\n",
    "        \"\"\"\n",
    "        if self.erreichte_punkte is not None and self.max_punkte > 0:\n",
    "            return (self.erreichte_punkte / self.max_punkte) * 100\n",
    "        return None\n",
    "\n",
    "    def ist_bestanden(self, grenze: float = 50.0) -> bool:\n",
    "        \"\"\"\n",
    "        Prüft, ob die Prüfungsleistung bestanden ist.\n",
    "        Standardmäßig gilt 50% als Bestehensgrenze.\n",
    "\n",
    "        :param grenze: Prozentgrenze zum Bestehen (Standard: 50.0)\n",
    "        :return: True, wenn bestanden, sonst False\n",
    "        \"\"\"\n",
    "        p = self.prozent()\n",
    "        return p is not None and p >= grenze\n",
    "\n",
    "    def __str__(self):\n",
    "        \"\"\"\n",
    "        Gibt eine lesbare Textdarstellung der Prüfungsleistung zurück.\n",
    "\n",
    "        :return: String mit Infos zur Prüfungsleistung\n",
    "        \"\"\"\n",
    "        punkte_str = f\"{self.erreichte_punkte}/{self.max_punkte}\" if self.erreichte_punkte is not None else f\"0/{self.max_punkte}\"\n",
    "        prozent_str = f\"{self.prozent():.1f}%\" if self.prozent() is not None else \"k.A.\"\n",
    "        status = \"bestanden\" if self.ist_bestanden() else \"nicht bestanden\"\n",
    "        datum_str = f\", Datum: {self.datum}\" if self.datum else \"\"\n",
    "        return f\"{self.titel}: {punkte_str} Punkte ({prozent_str}), {status}{datum_str}\"\n",
    "\n",
    "\n",
    "class Datenmanager:\n",
    "    def __init__(self, dateiname: str):\n",
    "        \"\"\"\n",
    "        Konstruktor für den Datenmanager.\n",
    "\n",
    "        :param dateiname: Name der JSON-Datei, in der die Daten gespeichert werden sollen\n",
    "        \"\"\"\n",
    "        self.dateiname = dateiname\n",
    "\n",
    "    def daten_speichern(self, user_liste: list):\n",
    "        \"\"\"\n",
    "        Speichert eine Liste von User-Objekten (und deren verschachtelte Daten) in einer JSON-Datei.\n",
    "\n",
    "        :param user_liste: Liste von User-Objekten\n",
    "        \"\"\"\n",
    "        # Wir müssen die Objekte in ein serialisierbares Format (z.B. Dictionaries) umwandeln\n",
    "        daten = [self.user_zu_dict(user) for user in user_liste]\n",
    "        with open(self.dateiname, 'w', encoding='utf-8') as f:\n",
    "            json.dump(daten, f, ensure_ascii=False, indent=4)\n",
    "\n",
    "    def daten_laden(self) -> list:\n",
    "        \"\"\"\n",
    "        Lädt die Daten aus der JSON-Datei und gibt eine Liste von User-Objekten zurück.\n",
    "\n",
    "        :return: Liste von User-Objekten\n",
    "        \"\"\"\n",
    "        try:\n",
    "            with open(self.dateiname, 'r', encoding='utf-8') as f:\n",
    "                daten = json.load(f)\n",
    "            return [self.dict_zu_user(user_dict) for user_dict in daten]\n",
    "        except FileNotFoundError:\n",
    "            return []\n",
    "\n",
    "    # Hilfsmethoden für die Umwandlung zwischen Objekten und Dictionaries\n",
    "\n",
    "    def user_zu_dict(self, user):\n",
    "        \"\"\"\n",
    "        Wandelt ein User-Objekt (mit allen verschachtelten Objekten) in ein Dictionary um.\n",
    "        \"\"\"\n",
    "        return {\n",
    "            \"name\": user.name,\n",
    "            \"matrikelnummer\": user.matrikelnummer,\n",
    "            \"studiengang\": self.studiengang_zu_dict(user.studiengang)\n",
    "        }\n",
    "\n",
    "    def studiengang_zu_dict(self, studiengang):\n",
    "        return {\n",
    "            \"name\": studiengang.name,\n",
    "            \"semester\": [self.semester_zu_dict(sem) for sem in studiengang.semester]\n",
    "        }\n",
    "\n",
    "    def semester_zu_dict(self, semester):\n",
    "        return {\n",
    "            \"name\": semester.name,\n",
    "            \"module\": [self.module_zu_dict(modul) for modul in semester.module]\n",
    "        }\n",
    "\n",
    "    def module_zu_dict(self, modul):\n",
    "        return {\n",
    "            \"titel\": modul.titel,\n",
    "            \"ects\": modul.ects,\n",
    "            \"pflicht\": modul.pflicht,\n",
    "            \"note\": modul.note,\n",
    "            \"bewertung\": modul.bewertung,\n",
    "            \"pruefungsleistungen\": [self.pruefungsleistung_zu_dict(p) for p in getattr(modul, 'pruefungsleistungen', [])]\n",
    "        }\n",
    "\n",
    "    def pruefungsleistung_zu_dict(self, pruefungsleistung):\n",
    "        return {\n",
    "            \"titel\": pruefungsleistung.titel,\n",
    "            \"max_punkte\": pruefungsleistung.max_punkte,\n",
    "            \"erreichte_punkte\": pruefungsleistung.erreichte_punkte,\n",
    "            \"datum\": pruefungsleistung.datum\n",
    "        }\n",
    "\n",
    "    # Methoden zum Wiederherstellen der Objekte aus Dictionaries\n",
    "\n",
    "    def dict_zu_user(self, d):\n",
    "        studiengang = self.dict_zu_studiengang(d[\"studiengang\"])\n",
    "        return User(d[\"name\"], d[\"matrikelnummer\"], studiengang)\n",
    "\n",
    "    def dict_zu_studiengang(self, d):\n",
    "        studiengang = Studiengang(d[\"name\"])\n",
    "        for sem_dict in d[\"semester\"]:\n",
    "            studiengang.semester.append(self.dict_zu_semester(sem_dict))\n",
    "        return studiengang\n",
    "\n",
    "    def dict_zu_semester(self, d):\n",
    "        semester = Semester(d[\"name\"])\n",
    "        for modul_dict in d[\"module\"]:\n",
    "            semester.module.append(self.dict_zu_module(modul_dict))\n",
    "        return semester\n",
    "\n",
    "    def dict_zu_module(self, d):\n",
    "        modul = Module(d[\"titel\"], d[\"ects\"], d[\"pflicht\"])\n",
    "        modul.note = d.get(\"note\")\n",
    "        modul.bewertung = d.get(\"bewertung\")\n",
    "        # Prüfungsleistungen hinzufügen, falls vorhanden\n",
    "        for p_dict in d.get(\"pruefungsleistungen\", []):\n",
    "            modul.pruefungsleistungen.append(self.dict_zu_pruefungsleistung(p_dict))\n",
    "        return modul\n",
    "\n",
    "    def dict_zu_pruefungsleistung(self, d):\n",
    "        return Pruefungsleistung(\n",
    "            d[\"titel\"],\n",
    "            d[\"max_punkte\"],\n",
    "            d.get(\"erreichte_punkte\"),\n",
    "            d.get(\"datum\")\n",
    "        )\n",
    "\n",
    "\n",
    "def modul_uebersicht_dataframe(user):\n",
    "    \"\"\"\n",
    "    Erstellt einen DataFrame mit allen Modulen und Prüfungsleistungen eines Users.\n",
    "\n",
    "    :param user: User-Objekt\n",
    "    :return: pandas DataFrame mit allen relevanten Spalten\n",
    "    \"\"\"\n",
    "    daten = []\n",
    "    for semester in user.studiengang.semester:\n",
    "        for modul in semester.module:\n",
    "            for pruef in getattr(modul, 'pruefungsleistungen', []):\n",
    "                prozent = pruef.prozent()\n",
    "                note = modul.note if modul.note is not None else \"-\"\n",
    "                bewertung = modul.bewertung if modul.bewertung is not None else \"-\"\n",
    "                status = \"bestanden\" if modul.ist_bestanden() else \"nicht bestanden\"\n",
    "                daten.append({\n",
    "                    \"Semester\": semester.name,\n",
    "                    \"Modul\": modul.titel,\n",
    "                    \"Prüfungsleistung\": pruef.titel,\n",
    "                    \"Max. Punkte\": pruef.max_punkte,\n",
    "                    \"Erreichte Punkte\": pruef.erreichte_punkte if pruef.erreichte_punkte is not None else \"-\",\n",
    "                    \"Prozent\": prozent,\n",
    "                    \"Note\": note,\n",
    "                    \"Bewertung\": bewertung,\n",
    "                    \"Status\": status\n",
    "                })\n",
    "    df = pd.DataFrame(daten)\n",
    "    return df\n",
    "\n",
    "\n",
    "def plot_ects_fortschritt(user):\n",
    "    \"\"\"\n",
    "    Erstellt ein einfaches Balkendiagramm für den ECTS-Fortschritt eines Users.\n",
    "\n",
    "    :param user: User-Objekt\n",
    "    \"\"\"\n",
    "    erreicht = user.aktueller_ects()\n",
    "    ziel = 180  # Beispiel für Bachelor\n",
    "    plt.bar(['Erreicht', 'Ziel'], [erreicht, ziel], color=['green', 'gray'])\n",
    "    plt.ylabel('ECTS')\n",
    "    plt.title('ECTS-Fortschritt')\n",
    "    plt.show()\n",
    "\n",
    "\n",
    "def dashboard_gui(user):\n",
    "    \"\"\"\n",
    "    Erstellt ein einfaches Dashboard-Fenster mit Tabelle und ECTS-Diagramm.\n",
    "\n",
    "    :param user: User-Objekt\n",
    "    \"\"\"\n",
    "    df = modul_uebersicht_dataframe(user)\n",
    "\n",
    "    root = tk.Tk()\n",
    "    root.title(\"Studien-Dashboard\")\n",
    "\n",
    "    # Tabelle anzeigen\n",
    "    tree = ttk.Treeview(root, columns=list(df.columns), show='headings')\n",
    "    for col in df.columns:\n",
    "        tree.heading(col, text=col)\n",
    "        tree.column(col, width=100)\n",
    "    for _, row in df.iterrows():\n",
    "        tree.insert('', tk.END, values=list(row))\n",
    "    tree.pack(fill='x')\n",
    "\n",
    "    # Diagramm (matplotlib) einbetten\n",
    "    fig, ax = plt.subplots(figsize=(4,2))\n",
    "    erreicht = user.aktueller_ects()\n",
    "    ziel = 180\n",
    "    ax.bar(['Erreicht', 'Ziel'], [erreicht, ziel], color=['green', 'gray'])\n",
    "    ax.set_ylabel('ECTS')\n",
    "    ax.set_title('ECTS-Fortschritt')\n",
    "    canvas = FigureCanvasTkAgg(fig, master=root)\n",
    "    canvas.draw()\n",
    "    canvas.get_tk_widget().pack()\n",
    "\n",
    "    root.mainloop()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python [conda env:base] *",
   "language": "python",
   "name": "conda-base-py"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
